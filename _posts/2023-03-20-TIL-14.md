---
layout: post
title: 'TIL #14'
category:
  - Today I Learned
tags:
  - JavaScript
date: '2023-03-20 23:04:00'
---

오늘은 동기, 비동기, 그리고 프로미스에 대해서 배웠다. 이전에 `mongoose`를 사용하다 문제가 발생했던 적이 있었는데, 이유는 코드가 예전에 작성된 코드여서 사용하는 `mongoose`의 버전 차이 때문에 발생한 문제였다.

최신 버전의`mongoose`에서는 더 이상 콜백 함수를 인자로 받는 것을 허용하지 않는다. 이 문제를 해결하려면 비동기를 사용해 해결해야 했고, 난 그 중`promise`를 사용해 해결했다. 사용은 해봤지만, 그 의미에 대해서는 확실하게 모르기에 배운것을 짚고 넘어가기 위해 정리를 해본다.

## 동기와 비동기

자바스크립트 엔진은 하나의 스레드(싱글 스레드)만을 가진다. 이는 동시에 2개 이상의 함수를 동시에 실행할 수 없다는 것을 의미한다.

**동기**란 현재 작업이 종료될 때까지 다음 작업이 대기하는 방식을 동기 처리라고 한다. 이와 반대로 **비동기**란 현재 작업이 종료되지 않은 상태라 해도 다음 작업을 바로 실행시키는 방식을 비동기 처리라고 한다.

## 이벤트 루프와 테스크 큐

자바스크립트 엔진은 힙(객체 저장)과 콜 스택(실행 컨텍스트 스택) 파트로 나뉘어지고, 브라우저 환경은 이벤트 루프와 태스크 큐로 구성돼 있다.

비동기 작업이 진행될 때 비동기 함수의 콜백 함수는 태스크 큐에 푸쉬되어 대기하다가 콜 스택이 비게 되면(빈것을 이벤트 루프가 확인해준다.), 콜스택으로 푸시돼 실행된다. 그렇기 때문에 `setTimeout `함수를 사용하게 되면 대략 몇초 뒤에 실행하겠다라고 시간을 설정해 줄 수 있지만, 실질적으로 내가 설정한 시간에 실행을 하지 않는다. 이유는 위에 설명한 이유 때문이다. 또한, 비동기 작업은 싱글스레드인 자바스크립트 엔진이 아니라 멀티 스레드인 브라우저에서 진행된다.

## Promise

```javascript
const promise = new Promise((resolve, reject) => {
		if (/* 비동기 성공 */)
			resolve();	// state: fulfilled
		else /* 비동기 실패*/
			reject();	// state: rejected
});

newPromise(value)
	.then((data) => {})
	.catch((error) => console.error(error))
	.finally()
```

콜백 헬을 막기 위한 ES6부터 도입된 대체제이다.

상태 정보는 3가지 형식이 있다.

1. pending(대기 상태)
2. fulfilled(비동기 처리 성공) -> `resolve()`
3. rejected(비동기 처리 실패) -> `reject()`
   성공시에는 `resolve`함수를 , 실패시에는 `reject`함수를 실행시켜준다.

프로미스로 비동기 처리시 후속 처리가 필요한데 이때 사용하는 것이 `.then, .catch, .finally`이다. 모든 후속 처리 메서드는 프로미스를 반환하며, 비동기로 동작한다.
`fulfilled`상태인 경우, `.then`을 실행하게 된다.
`rejected`상태인 경우, `.catch`를 통해서 에러 처리를 해줄 수 있다.
`.finally`는 어떤 상태던 간에 무조건 한번 실행을 해준다(`do-while`의 `do` 같은 느낌).

프로미스에서 여러 메소드를 체이닝해서 사용하는 것을 **프로미스 체이닝**이라고 한다.

---

### Reference

- 모던 자바스크립트 Deep Dive(이웅모, 위키북스)
