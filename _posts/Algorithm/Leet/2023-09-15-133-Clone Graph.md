---
layout: post
title: '133.Â Clone Graph'
category:
  - Algorithm
tags:
  - JavaScript
  - Leet Code
date: '2023-09-15T01:35:00+09:00'
---

## [ğŸ”—](https://leetcode.com/problems/clone-graph/) ë¬¸ì œ

> **Medium**
>
> Given a reference of a node in aÂ **[connected](https://en.wikipedia.org/wiki/Connectivity_%28graph_theory%29#Connected_graph)**Â undirected graph.
> Return aÂ **[deep copy](https://en.wikipedia.org/wiki/Object_copying#Deep_copy)**Â (clone) of the graph.
> Each node in the graph contains a value (int) and a list (List[Node]) of its neighbors.
>
> ```typescript
> class Node {
>     public int val;
>     public List<Node> neighbors;
> }
> ```
>
> **Test case format:**
> For simplicity, each node's value is the same as the node's index (1-indexed). For example, the first node withÂ val == 1, the second node withÂ val == 2, and so on. The graph is represented in the test case using an adjacency list.
> **An adjacency list**Â is a collection of unorderedÂ **lists**Â used to represent a finite graph. Each list describes the set of neighbors of a node in the graph.
> The given node will always be the first node withÂ val = 1. You must return theÂ **copy of the given node**Â as a reference to the cloned graph.
>
>
>
> - **Example 1:** > ![133_clone_graph_question](https://assets.leetcode.com/uploads/2019/11/04/133_clone_graph_question.png)
>   ```
>   Input: adjList = [[2,4],[1,3],[2,4],[1,3]]
>   Output: [[2,4],[1,3],[2,4],[1,3]]
>   Explanation: There are 4 nodes in the graph.
>     1st node (val = 1)'s neighbors are 2nd node (val = 2) and 4th node (val = 4).
>     2nd node (val = 2)'s neighbors are 1st node (val = 1) and 3rd node (val = 3).
>     3rd node (val = 3)'s neighbors are 2nd node (val = 2) and 4th node (val = 4).
>     4th node (val = 4)'s neighbors are 1st node (val = 1) and 3rd node (val = 3).
>   ```
> - **Example 2:** > ![graph](https://assets.leetcode.com/uploads/2020/01/07/graph.png)
>   ```
>   Input: adjList = [[]]
>   Output: [[]]
>   Explanation: Note that the input contains one empty list. The graph consists of only one node with val = 1 and it does not have any neighbors.
>   ```
> - **Example 3:**
>   ```
>   Input: adjList = []
>   Output: []
>   Explanation: This an empty graph, it does not have any nodes.
>   ```

### í’€ì´

ì´ ë¬¸ì œëŠ” ì¸ì ‘ ë¦¬ìŠ¤íŠ¸(Adjancency List)ë¡œ êµ¬í˜„ëœ Graphë¥¼ ê¹Šì€ ë³µì‚¬í•˜ì—¬ í´ë¡ ëœ ê·¸ë˜í”„ë¥¼ ë°˜í™˜í•´ì£¼ëŠ” ë¬¸ì œì´ë‹¤. `cloneGraph`ì—ì„œ ë§¤ê°œë³€ìˆ˜ë¡œ ë“¤ì–´ì˜¤ëŠ” `node`ê°€ Graphë¥¼ êµ¬ì„±í•˜ê³  ìˆëŠ” ì •ì  ì¤‘ í•˜ë‚˜ì´ë‹¤. `neighbors`ëŠ” ì´ ì •ì ì™€ ì¸ì ‘í•´ ìˆëŠ” ë‹¤ë¥¸ `node`ë¥¼ ë‹´ê³  ìˆë‹¤.

```javascript
/**
 * // Definition for a Node.
 * function Node(val, neighbors) {
 *    this.val = val === undefined ? 0 : val;
 *    this.neighbors = neighbors === undefined ? [] : neighbors;
 * };
 */

/*
 * @param {Node} node
 * @return {Node}
 */
var cloneGraph = function (node) {
  let stack = [];
  let visited = new Map();
  let clone = new Map();

  if (!node) {
    return null;
  }
  if (!node.neighbors.length) {
    return { val: node.val, neighbors: [] };
  }

  // DFS
  stack.push(node);

  while (stack.length) {
    let current = stack.pop();

    if (!visited.has(current)) {
      let list = [];
      let cloneVertex;

      for (let i = 0; i < current.neighbors.length; i++) {
        stack.push(current.neighbors[i]);
        list.push(current.neighbors[i].val);
      }
      cloneVertex = { val: current.val, neighbors: list };
      visited.set(current, true);
      if (!clone.has(cloneVertex)) {
        clone.set(current.val, cloneVertex);
      }
    }
  }

  // neighbors value ë§¤ì¹­
  let iter = clone.values();
  let flag = false;
  while (true) {
    let vertex = iter.next().value;
    if (!flag) {
      node = vertex;
      flag = true;
    }
    if (!vertex) break;
    for (let i in vertex.neighbors) {
      vertex.neighbors[i] = clone.get(vertex.neighbors[i]);
    }
    clone.set(vertex.val, vertex);
  }

  return node;
};
```

Graph íƒìƒ‰ì„ ìœ„í•´ DFS ì•Œê³ ë¦¬ì¦˜ì„ ì‚¬ìš©í–ˆë‹¤. DFS ì•Œê³ ë¦¬ì¦˜ì€ ìŠ¤íƒê³¼ `visited`ë¼ëŠ” í•´ì‰¬ í…Œì´ë¸”ì„ ì‚¬ìš©í•´ êµ¬í˜„í–ˆë‹¤. ê¹Šì€ ë³µì‚¬ë¥¼ í•˜ë ¤ë©´ ê° ì •ì ì— í•´ë‹¹ë˜ëŠ” ê°ì²´ì˜ ì°¸ì¡°ê°’ì„ ì•Œì•„ì•¼ í•˜ëŠ”ë°, ì´ë¥¼ êµ¬í˜„í•˜ê¸° ìœ„í•´ `clone`ì´ë¼ëŠ” í•´ì‰¬ í…Œì´ë¸”ì„ ì‚¬ìš©í–ˆë‹¤.

**clone(í•´ì‰¬ í…Œì´ë¸”)**

- key: vertexì˜ value
- value: `{ val: vertexì˜ value, neighbors: [neighborsì˜ valueë“¤]}`
  ì˜ˆì‹œ) `{val: 1, neighbors: [2, 4]}`

`clone`ì˜ valueì— ê°ì²´ì˜ ì°¸ì¡°ê°’ìœ¼ë¡œ ì €ì¥í•˜ì—¬, `get(vertexì˜ value)`ë¥¼ ì´ìš©í•´ ì°¸ì¡°ê°’ì„ ê°€ì ¸ì˜¬ ìˆ˜ ìˆê²Œ êµ¬í˜„í–ˆë‹¤. DFS ì•Œê³ ë¦¬ì¦˜ì´ ì§„í–‰ë˜ëŠ” ë™ì•ˆ, `clone`ì—ëŠ” ê° ê·¸ë˜í”„ì˜ ì •ì ì´ ê°–ê³  ìˆëŠ” `value`ì™€ `neighbors`ì˜ `value`ë“¤ì„ ì €ì¥ëœë‹¤.

DFSê°€ ëë‚˜ê²Œ ë˜ë©´ Graphê°€ ê°€ì§€ëŠ” ì •ì ì˜ ê°¯ìˆ˜ë§Œí¼ì˜ í•´ì‰¬ ê°’ë“¤ì´ ìƒì„±ëœë‹¤. Map ê°ì²´ì˜ iterableí•œ ì„±ì§ˆì„ í™œìš©í•´, ìˆœì°¨ì ìœ¼ë¡œ ê° `node`ì— ì ‘ê·¼í•˜ë©° `neighbors`ì˜ `value`ê°’ë“¤ì„ í•´ë‹¹í•˜ëŠ” ì •ì ê³¼ ë§¤ì¹­ì‹œì¼œì£¼ì—ˆë‹¤. ê° `value`ì™€ ì •ì ë¼ë¦¬ ë§¤ì¹­í•˜ê¸° ìœ„ì— ì•„ê¹Œ ìœ„ì—ì„œ ìƒì„±í•œ `clone` í•´ì‰¬ í…Œì´ë¸”ì„ ì‚¬ìš©í–ˆë‹¤(`get(vertexì˜ value)`).

### ë‹¤ë¥¸ í’€ì´

```javascript
/**
 * // Definition for a Node.
 * function Node(val, neighbors) {
 *    this.val = val === undefined ? 0 : val;
 *    this.neighbors = neighbors === undefined ? [] : neighbors;
 * };
 */

/**
 * @param {Node} node
 * @return {Node}
 */
var cloneGraph = function (node) {
  if (node == null) return node;
  const visited = new Map();
  return cloneHelper(node, visited);
};

var cloneHelper = function (node, visited) {
  const newNode = new Node(node.val);
  visited.set(node.val, newNode);

  for (const neighbor of node.neighbors) {
    if (!visited.has(neighbor.val)) {
      const newNeighbor = cloneHelper(neighbor, visited);
      newNode.neighbors.push(newNeighbor);
    } else {
      const newNeighbor = visited.get(neighbor.val);
      newNode.neighbors.push(newNeighbor);
    }
  }
  return newNode;
};
```

ê¸°ì¡´ ì½”ë“œëŠ” visitedë¥¼ ë°°ì—´ë¡œ ì‚¬ìš©í•˜ê³  ìˆì—ˆëŠ”ë°, ì‚¬ì‹¤ìƒ visitedë¥¼ key-value í˜•ì‹ìœ¼ë¡œ ì‚¬ìš©í•˜ê³  ìˆê¸° ë•Œë¬¸ì— í•´ì‰¬ í…Œì´ë¸”ë¡œ ìˆ˜ì •í•´ì£¼ì—ˆë‹¤.

ë¬¸ì œë¥¼ í•´ê²°í•˜ëŠ” ë„ì¤‘, ê°€ì¥ ê¶ê¸ˆí–ˆë˜ ì ì´ `neighbors`ì— í•´ë‹¹í•˜ëŠ” ê°ì²´ë“¤ì„ ì–´ë–»ê²Œ ìƒì„±í• ê²ƒì¸ê°€ì— ëŒ€í•œ ê²ƒì´ì—ˆë‹¤. `neighbors`ë¥¼ ì¬ê·€ì ìœ¼ë¡œ ìƒì„±í•´ì•¼ í• ê²ƒ ê°™ë‹¤ëŠ” ìƒê°ì€ ë“¤ì—ˆìœ¼ë‚˜, ì–´ë–»ê²Œ ì ‘ê·¼í•´ì•¼ í• ì§€ë¥¼ ëª°ë¼ ë‚˜ì˜ ê²½ìš° `clone`ì´ë¼ëŠ” í•´ì‰¬ í…Œì´ë¸”ì„ ì‚¬ìš©í•˜ì—¬ ë¬¸ì œë¥¼ í•´ê²°í–ˆë‹¤. ì¬ê·€ë¥¼ ì‚¬ìš©í•´ í‘¼ ìœ„ì˜ í’€ì´ë¥¼ í†µí•´ ê¶ê¸ˆí–ˆë˜ ì ì„ í•´ì†Œí•  ìˆ˜ ìˆì—ˆë‹¤.

ìœ„ì˜ í’€ì´ë¥¼ ë³´ë©´ `for`ë¬¸ì„ ì‚¬ìš©í•´ ìˆœì°¨ì ìœ¼ë¡œ `node.neighbors`ê°€ ê°€ì§„ `neighbor`ì— ì ‘ê·¼ì„ í•œë‹¤. ì´ë¯¸ ë…¸ë“œì— ë°©ë¬¸ì„ í–ˆë‹¤ë©´ `visited`ì— ì €ì¥ëœ ì •ì ì— ëŒ€í•œ ì°¸ì¡°ê°’ì„ ê°€ì ¸ì˜¤ê³ , ê·¸ë ‡ì§€ ì•Šë‹¤ë©´ `cloneHelper`ë¥¼ í˜¸ì¶œí•´ `neighbor` ë…¸ë“œë¡œ ë„˜ì–´ê°€ í•´ë‹¹ `neighbor` ë…¸ë“œê°€ ê°€ì§€ëŠ” `neighbors` ê°’ë“¤ì„ íƒìƒ‰í•œë‹¤. ê·¸ëŸ¼ìœ¼ë¡œì¨ `neighbors`ê°€ ì¬ê·€ì ìœ¼ë¡œ ìƒì„±ì´ ë˜ê²Œ ëœë‹¤.

example1 ì˜ˆì‹œë¥¼ í†µí•´ ì§„í–‰ ìˆœì„œë¥¼ ë‚˜ì—´í•´ë³´ë©´, 1(ì—´ë¦¼) â¡ï¸ 2(ì—´ë¦¼) â¡ï¸ 3(ì—´ë¦¼) â¡ï¸ 4(ì—´ë¦¼, ë‹«í˜) â¡ï¸ 3(ë‹«í˜) â¡ï¸ 2(ë‹«í˜) â¡ï¸ 1(ë‹«í˜)ìˆœìœ¼ë¡œ ì§„í–‰ë˜ê²Œ ëœë‹¤. ìµœì¢…ì ìœ¼ë¡œëŠ” nodeì˜ ê°€ì¥ ì´ˆê¸°ê°’ìœ¼ë¡œ ëŒì•„ì˜¤ê²Œ ë˜ê³ , ì´ë¥¼ ë°˜í™˜í•˜ê²Œ ëœë‹¤.

---

### Reference

- [Easy understand javascript solution](https://leetcode.com/problems/clone-graph/solutions/2661707/easy-understand-javascript-solution/?envType=study-plan-v2&envId=top-interview-150#:~:text=Easy%20understand%20javascript%20solution)
